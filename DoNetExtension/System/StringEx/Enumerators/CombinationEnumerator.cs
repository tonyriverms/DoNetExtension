using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace System
{
    public static partial class StringEx
    {
        /// <summary>
        /// Gets an enumerator that can iterate through certain combinations of strings specified in this combination expression.
        /// </summary>
        /// <param name="expression">A combination expression to indicate what strings are used for combination and how they are combined.</param>
        /// <param name="parameterGroupSeparator">A Unicode character used as the separator to delimit different types of arguments.</param>
        /// <param name="parameterSeparator">A Unicode character used as the separator to delimit different arguments of the same type.</param>
        /// <param name="parameterLeftBracket">A Unicode character right paired by the <paramref name="parameterRightBracket"/> to bracket the argument part.</param>
        /// <param name="parameterRightBracket">A Unicode character left paired by the <paramref name="parameterLeftBracket"/> to bracket the argument part.</param>
        /// <param name="leftQuote">A Unicode character right paired by the <paramref name="rightQuote"/> to escape <paramref name="parameterGroupSeparator"/> and <paramref name="parameterSeparator"/>.</param>
        /// <param name="rightQuote">A Unicode character left paired by the <paramref name="leftQuote"/> to escape <paramref name="parameterGroupSeparator"/> and <paramref name="parameterSeparator"/>.</param>
        /// <returns>An enumerator object that can be used to iterate through combinations of strings specified in the <paramref name="expression"/>.</returns>
        /// <remarks>
        /// A combination expression consists of two parts, the combination method and the bracketed argument part, which looks like "point(1,2,3)", where "point" is the combination method and "1,2,3" inside a pair of round brackets is the argument.
        /// <para>Three types of combination methods are supported.</para>
        /// <list type="bullet">
        ///     <term>cube</term>
        ///     <description>the returned enumerator will go through all combitnations of the keywords if no argument is provided, for example, the enumerator generated by "cube(1,2,3)" will enum {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3} in order. This method can also go through combinations according to the argument and it is the only method that accepts the depth and the count argument indicating what combinations the enumerator can go through. This method also supports the randomness argument.</description>
        ///     <term>square</term>
        ///     <description>the returned enumerator will go through every single keyword and every 2-gram combination. For example, the enumerator generated by "square(1,2,3)" will enum {1}, {2}, {3}, {1,2}, {1,3}, {2,3} in order. This method only supports the randomness argument.</description>
        ///     <term>point</term>
        ///     <description>the returned enumerator will only go through every single keyword. For example, the enumerator generated by "square(1,2,3)" will enum {1}, {2}, {3} in order. This method only supports the randomness argument.</description>
        /// </list>
        /// <para>The <c>cube</c> method supports three types of argument besides the keywords.</para>
        /// <list type="bullet">
        ///     <term>depth</term>
        ///     <description>indicating the minimum and the maximum length of each combination. For example, cube(a,b,c; 2) returns {a,b}, {a,c} and {b,c}, for the depth argument "2" indicates only 2-gram combinations should be returned. There can be more than one depth argument and one depth can overlap the other, for example, cube(a,b,c; 2-3,1-2) will return {a,b}, {a,c}, {b,c}, {a,b,c}, {a}, {b}, {c}, {a,b}, {a,c} and {b,c}.</description>
        ///     <term>count</term>
        ///     <description>indicating how many combinations are returned for each depth argument. For example, cube(a,b,c; 2; 1) only returns {a,b}, for the count argument "1" indicates only one 2-gram combination should be returned. For another example, cube(a,b,c; 2-3,1-2; 2,3) will return {a,b}, {a,c}, {a}, {b}, {c}, because the count arguments indicate the enumerator should go through only two combinations for depth 2-3, and threee combinations for depth 1-2.</description>
        ///     <term>randomness</term>
        ///     <description>all three methods, <c>cube</c>, <c>squre</c> and <c>point</c>. Currently you can specify "static" and "random" for this argument. If "static" is specified, the combinations will come out in sequence, as demonstrated by all above examples; if "random" is specified, the order of the combinations will be randomized, for example, "point(a,b,c; random)" might return {b}, {c}, {a}, and might also return {a}, {c}, {b}.</description>
        /// </list>
        /// NOTE that the depth arguments and the count arguments are optional, and expressions like "cube(a,b,c; random)", "cube(a,b,c; 1-2; random)" are valid. Also NOTE that if the depth arguments are not specified, then the count arguments should not be used, for the count argument correspond to the depth arguments.
        /// </remarks>
        public static IEnumerator<string[]> GetComboEnumerator(this string expression,
            char parameterGroupSeparator = ';',
            char parameterSeparator = ',',
            char parameterLeftBracket = '(',
            char parameterRightBracket = ')',
            char leftQuote = '[',
            char rightQuote = ']')
        {
            return (new StringReader(expression)).GetComboEnumerator(parameterGroupSeparator, parameterSeparator, parameterLeftBracket, parameterRightBracket, leftQuote, rightQuote);
        }

        /// <summary>
        /// Gets an enumerator that can iterate through certain combinations of objects of type <typeparamref name="T"/> converted from strings specified in this combination expression.
        /// </summary>
        /// <typeparam name="T">The type of objects generated by the returned enumerator.</typeparam>
        /// <param name="expression">A combination expression to indicate what strings are used for combination and how they are combined.</param>
        /// <param name="converter">Provides a method that converts each string instance of a combination to an object of type <typeparamref name="T"/>.</param>
        /// <param name="parameterGroupSeparator">A Unicode character used as the separator to delimit different types of arguments.</param>
        /// <param name="parameterSeparator">A Unicode character used as the separator to delimit different arguments of the same type.</param>
        /// <param name="parameterLeftBracket">A Unicode character right paired by the <paramref name="parameterRightBracket" /> to bracket the argument part.</param>
        /// <param name="parameterRightBracket">A Unicode character left paired by the <paramref name="parameterLeftBracket" /> to bracket the argument part.</param>
        /// <param name="leftQuote">A Unicode character right paired by the <paramref name="rightQuote" /> to escape <paramref name="parameterGroupSeparator" /> and <paramref name="parameterSeparator" />.</param>
        /// <param name="rightQuote">A Unicode character left paired by the <paramref name="leftQuote" /> to escape <paramref name="parameterGroupSeparator" /> and <paramref name="parameterSeparator" />.</param>
        /// <returns>An enumerator object that can be used to iterate through objects of type <typeparamref name="T"/> converted from combinations of strings specified in the <paramref name="expression" />.</returns>
        /// <remarks>For syntax, please refer to the other overload of this method.</remarks>
        public static IEnumerator<T[]> GetComboEnumerator<T>(this string expression, Func<string, T> converter,
            char parameterGroupSeparator = ';',
            char parameterSeparator = ',',
            char parameterLeftBracket = '(',
            char parameterRightBracket = ')',
            char leftQuote = '[',
            char rightQuote = ']')
        {
            return (new StringReader(expression)).GetComboEnumerator<T>(converter, parameterGroupSeparator, parameterSeparator, parameterLeftBracket, parameterRightBracket, leftQuote, rightQuote);
        }
    }
}
