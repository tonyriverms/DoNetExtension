using System.Collections;
using System.Collections.Generic;
using System.Reflection;

namespace System
{

    public enum UpdateResult : byte
    {
        NoChange = 0,
        Updated = 1,
        Added = 2
    }

    public static partial class ArrayEx
    {
        #region Dictionary Creation

        /// <summary>
        /// Converts an array of <typeparamref ref="TKey"/> objects into a <see cref="System.Collections.Generic.Dictionary{TKey,TValue}"/> using the current array as keys
        /// and <paramref name="values"/> as corresponding values.
        /// </summary>
        /// <typeparam name="TKey">The type of objects in this array. They are used as keys in the returned dictionary.</typeparam>
        /// <typeparam name="TValue">The type of objects as values in the returned dictionary.</typeparam>
        /// <param name="keys">The current array as keys.</param>
        /// <param name="values">The values to be associated with the keys in the returned dictionary.</param>
        /// <returns>A dictionary with key-value pairs from the current array and the provided <paramref name="values"/>.</returns>
        public static Dictionary<TKey, TValue> ToDictionary<TKey, TValue>(this TKey[] keys, TValue[] values)
        {
            var count = keys.Length;
            var dict = new Dictionary<TKey, TValue>(count);
            for (var i = 0; i < count; ++i)
                dict.Add(keys[i], values[i]);
            return dict;
        }

        /// <summary>
        /// Converts a sequence of <see cref="KeyValuePair{TKey,TValue}"/> into a <see cref="System.Collections.Generic.Dictionary{TKey,TValue}"/>.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="keyValueCollection">The key/value sequence.</param>
        /// <returns>A new <see cref="System.Collections.Generic.Dictionary{TKey,TValue}"/> containing the key/value sequence.</returns>
        public static Dictionary<TKey, TValue> ToDictionary<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> keyValueCollection)
        {
            return new Dictionary<TKey, TValue> { keyValueCollection };
        }

        /// <summary>
        /// Converts an enumerator of <see cref="KeyValuePair{TKey,TValue}"/> objects into a <see cref="System.Collections.Generic.Dictionary{TKey,TValue}"/>.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="enumerator">The enumerator of <see cref="KeyValuePair{TKey,TValue}"/> objects.</param>
        /// <returns>A new <see cref="System.Collections.Generic.Dictionary{TKey,TValue}"/> containing all key/value pairs generated by the provided enumerator.</returns>
        public static Dictionary<TKey, TValue> ToDictionary<TKey, TValue>(this IEnumerator<KeyValuePair<TKey, TValue>> enumerator)
        {
            return new Dictionary<TKey, TValue> { enumerator };
        }

        /// <summary>
        /// Converts a sequence of <see cref="Pair{TKey,TValue}"/> into a <see cref="System.Collections.Generic.Dictionary{TKey,TValue}"/>.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="keyValueCollection">A sequence of pairs where the first item of each pair is used as the key to index the second item.</param>
        /// <returns>A new <see cref="System.Collections.Generic.Dictionary{TKey,TValue}"/> containing the key/value sequence.</returns>
        public static Dictionary<TKey, TValue> ToDictionary<TKey, TValue>(this IEnumerable<Pair<TKey, TValue>> keyValueCollection)
        {
            var dict = new Dictionary<TKey, TValue>();
            foreach (var pair in keyValueCollection)
                dict.Add(pair.Item1, pair.Item2);
            return dict;
        }

        /// <summary>
        /// Converts a sequence of (<typeparamref name="TKey"/>,<typeparamref name="TValue"/>) tuples into a <see cref="System.Collections.Generic.Dictionary{TKey,TValue}"/>.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="keyValueCollection">The key/value sequence.</param>
        /// <returns>A new <see cref="System.Collections.Generic.Dictionary{TKey,TValue}"/> containing the key/value sequence.</returns>
        public static Dictionary<TKey, TValue> ToDictionary<TKey, TValue>(this IEnumerable<(TKey, TValue)> keyValueCollection)
        {
            var dict = new Dictionary<TKey, TValue>();
            foreach (var pair in keyValueCollection)
                dict.Add(pair.Item1, pair.Item2);
            return dict;
        }

        /// <summary>
        /// Returns a new <see cref="Dictionary{TValue, TKey}"/> object that copies key-value pairs from the current dictionary with key and value of each entry exchanged.
        /// </summary>
        /// <typeparam name="TKey">The type of the key in the current dictionary.</typeparam>
        /// <typeparam name="TValue">The type of the value in the current dictionary.</typeparam>
        /// <param name="dict">The current dictionary.</param>
        /// <returns>A new <see cref="Dictionary{TValue, TKey}"/> object that copies key-value pairs from the current dictionary with key and value of each entry exchanged.</returns>
        public static Dictionary<TValue, TKey> ToValueIndexedDictionary<TKey, TValue>(this IDictionary<TKey, TValue> dict)
        {
            var output = new Dictionary<TValue, TKey>(dict.Count);
            foreach (var pair in dict)
                output.Add(pair.Value, pair.Key);
            return output;
        }

        /// <summary>
        /// Converts a sequence of objects with <c>Item1</c> and <c>Item2</c> fields or properties into a <see cref="System.Collections.Generic.Dictionary{TKey,TValue}"/>.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="keyValueCollection">A sequence of object with <c>Item1</c> and <c>Item2</c> fields or properties, where the <c>Item1</c> of each pair is used as the key to index the <c>Item2</c>.</param>
        /// <returns>A new <see cref="System.Collections.Generic.Dictionary{TKey,TValue}"/> containing the key/value sequence.</returns>
        public static Dictionary<TKey, TValue> ToDictionary<TKey, TValue>(this IEnumerable<object> keyValueCollection)
        {
            var dict = new Dictionary<TKey, TValue>();
            foreach (var pair in keyValueCollection)
                dict.Add(((dynamic)pair).Item1, ((dynamic)pair).Item2);
            return dict;
        }

        /// <summary>
        /// Copies all entries in the current dictionary to another dictionary with the key and value of each entry exchanged.
        /// </summary>
        /// <typeparam name="TKey">The type of the key in the current dictionary.</typeparam>
        /// <typeparam name="TValue">The type of the value in the current dictionary.</typeparam>
        /// <param name="dict">The current dictionary.</param>
        /// <param name="target">Each key-value pair of the current dictionary will be copied to this target dictionary with key and value exchanged.</param>
        public static void ToValueIndexedDictionary<TKey, TValue>(this IDictionary<TKey, TValue> dict, IDictionary<TValue, TKey> target)
        {
            foreach (var pair in dict)
                target.Add(pair.Value, pair.Key);
        }

        /// <summary>
        /// Returns a new <see cref="Dictionary{TValue1, TKey}" /> object that uses the first item of each of the tuple in the current dictionary as the key of the new dictionary, while it copies corresponding key of the current dictionary as the value for the new dictionary.
        /// </summary>
        /// <typeparam name="TKey">The type of the key in the current dictionary.</typeparam>
        /// <typeparam name="TValue1">The type of the first item of the tuple value in the current dictionary.</typeparam>
        /// <typeparam name="TValue2">The type of the second item of the tuple value in the current dictionary.</typeparam>
        /// <param name="dict">The current dictionary.</param>
        /// <returns>A new <see cref="Dictionary{TValue1, TKey}" /> object that uses the first item of each tuple in the current dictionary as the keys to index keys in the current dictionary.</returns>
        public static Dictionary<TValue1, TKey> ToFirstItemIndexedDictionary<TKey, TValue1, TValue2>(this IDictionary<TKey, (TValue1, TValue2)> dict)
        {
            var output = new Dictionary<TValue1, TKey>(dict.Count);
            foreach (var pair in dict)
                output.Add(pair.Value.Item1, pair.Key);
            return output;
        }


        /// <summary>
        /// Returns a new <see cref="Dictionary{TValue1, TKey}" /> object that uses the first item of each of the tuple in the current dictionary as the key of the new dictionary, while it copies corresponding key of the current dictionary as the value for the new dictionary.
        /// </summary>
        /// <typeparam name="TKey">The type of the key in the current dictionary.</typeparam>
        /// <typeparam name="TValue1">The type of the first item of the tuple value in the current dictionary.</typeparam>
        /// <typeparam name="TValue2">The type of the second item of the tuple value in the current dictionary.</typeparam>
        /// <typeparam name="TValue3">The type of the third item of the tuple value in the current dictionary.</typeparam>
        /// <param name="dict">The current dictionary.</param>
        /// <returns>A new <see cref="Dictionary{TValue1, TKey}" /> object that uses the first item of each tuple in the current dictionary as the keys to index keys in the current dictionary.</returns>
        public static Dictionary<TValue1, TKey> ToFirstItemIndexedDictionary<TKey, TValue1, TValue2, TValue3>(this IDictionary<TKey, (TValue1, TValue2, TValue3)> dict)
        {
            var output = new Dictionary<TValue1, TKey>(dict.Count);
            foreach (var pair in dict)
                output.Add(pair.Value.Item1, pair.Key);
            return output;
        }

        /// <summary>
        /// Returns a new <see cref="Dictionary{TValue1, TKey}" /> object that uses the second item of each of the tuple in the current dictionary as the key of the new dictionary, while it copies corresponding key of the current dictionary as the value for the new dictionary.
        /// </summary>
        /// <typeparam name="TKey">The type of the key in the current dictionary.</typeparam>
        /// <typeparam name="TValue1">The type of the first item of the tuple value in the current dictionary.</typeparam>
        /// <typeparam name="TValue2">The type of the second item of the tuple value in the current dictionary.</typeparam>
        /// <param name="dict">The current dictionary.</param>
        /// <returns>A new <see cref="Dictionary{TValue1, TKey}" /> object that uses the second item of each tuple in the current dictionary as the keys to index keys in the current dictionary.</returns>
        public static Dictionary<TValue2, TKey> ToSecondItemIndexedDictionary<TKey, TValue1, TValue2>(this IDictionary<TKey, (TValue1, TValue2)> dict)
        {
            var output = new Dictionary<TValue2, TKey>(dict.Count);
            foreach (var pair in dict)
                output.Add(pair.Value.Item2, pair.Key);
            return output;
        }


        /// <summary>
        /// Returns a new <see cref="Dictionary{TValue1, TKey}" /> object that uses the second item of each of the tuple in the current dictionary as the key of the new dictionary, while it copies corresponding key of the current dictionary as the value for the new dictionary.
        /// </summary>
        /// <typeparam name="TKey">The type of the key in the current dictionary.</typeparam>
        /// <typeparam name="TValue1">The type of the first item of the tuple value in the current dictionary.</typeparam>
        /// <typeparam name="TValue2">The type of the second item of the tuple value in the current dictionary.</typeparam>
        /// <typeparam name="TValue3">The type of the third item of the tuple value in the current dictionary.</typeparam>
        /// <param name="dict">The current dictionary.</param>
        /// <returns>A new <see cref="Dictionary{TValue1, TKey}" /> object that uses the second item of each tuple in the current dictionary as the keys to index keys in the current dictionary.</returns>
        public static Dictionary<TValue1, TKey> ToSecondItemIndexedDictionary<TKey, TValue1, TValue2, TValue3>(this IDictionary<TKey, (TValue1, TValue2, TValue3)> dict)
        {
            var output = new Dictionary<TValue1, TKey>(dict.Count);
            foreach (var pair in dict)
                output.Add(pair.Value.Item1, pair.Key);
            return output;
        }

        /// <summary>
        /// Returns a new <see cref="Dictionary{TValue1, TKey}" /> object that uses the third item of each of the tuple in the current dictionary as the key of the new dictionary, while it copies corresponding key of the current dictionary as the value for the new dictionary.
        /// </summary>
        /// <typeparam name="TKey">The type of the key in the current dictionary.</typeparam>
        /// <typeparam name="TValue1">The type of the first item of the tuple value in the current dictionary.</typeparam>
        /// <typeparam name="TValue2">The type of the second item of the tuple value in the current dictionary.</typeparam>
        /// <typeparam name="TValue3">The type of the third item of the tuple value in the current dictionary.</typeparam>
        /// <param name="dict">The current dictionary.</param>
        /// <returns>A new <see cref="Dictionary{TValue1, TKey}" /> object that uses the third item of each tuple in the current dictionary as the keys to index keys in the current dictionary.</returns>
        public static Dictionary<TValue1, TKey> ToThirdItemIndexedDictionary<TKey, TValue1, TValue2, TValue3>(this IDictionary<TKey, (TValue1, TValue2, TValue3)> dict)
        {
            var output = new Dictionary<TValue1, TKey>(dict.Count);
            foreach (var pair in dict)
                output.Add(pair.Value.Item1, pair.Key);
            return output;
        }

        #endregion


        #region Value Retrieval

        /// <summary>
        /// Gets the value associated with the specified <paramref name="key"/> and converts it to the type specified by <typeparamref name="TValue"/>.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type to which the retrieved value is converted.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="key">The key.</param>
        /// <param name="value">Outputs the retrieved and converted value. If <paramref name="key"/> does not exist, the default value of <typeparamref name="TValue"/> will be returned. </param>
        /// <returns><c>true</c> if <paramref name="key"/> exists in the dictionary, <c>false</c> otherwise.</returns>
        public static bool TryGetValue<TKey, TValue>(this IDictionary<TKey, object> dict, TKey key, out TValue value)
        {
            if (dict.TryGetValue(key, out var tmp))
            {
                value = (TValue)tmp;
                return true;
            }
            else
            {
                value = default;
                return false;
            }
        }

        /// <summary>
        /// Tries to get the the value associated with the specified key. If the specified key does not exists, <paramref name="defaultValue"/> will be returned.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="key">The key whose value to get.</param>
        /// <param name="defaultValue">The default value to be returned if the specified <paramref name="key"/> does not exist in the dictionary.</param>
        /// <returns>The value associated with the specified key, if the key is found; otherwise, <paramref name="defaultValue"/>.</returns>
        public static TValue TryGetValueOrDefault<TKey, TValue>(this IDictionary<TKey, TValue> dict, TKey key, TValue defaultValue = default)
        {
            return dict.TryGetValue(key, out var value) ? value : defaultValue;
        }

        /// <summary>
        /// Tries to get the the values associated with the specified <paramref name="keys" /> and at specified <paramref name="index" /> of the value array. Keys that do not exist in the dictionary are ignored.
        /// </summary>
        /// <typeparam name="TKey">The type of keys.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="keys">The keys whose values to get.</param>
        /// <param name="index">The index of the value in the value array.</param>
        /// <returns>The values associated with the specified specified <paramref name="keys" /> and at the specified <paramref name="index" /> of the value array, if they exist in the dictionary.</returns>
        public static TValue[] TryGetValues<TKey, TValue>(this IDictionary<TKey, TValue[]> dict, TKey[] keys, int index)
        {
            var keycount = keys.Length;
            var output = new List<TValue>(keycount);
            for (var i = 0; i < keycount; ++i)
            {
                if (dict.TryGetValue(keys[i], out TValue[] values))
                    output.Add(values[index]);
            }
            return output.ToArray();
        }

        /// <summary>
        /// Tries to get the the values associated with the specified <paramref name="keys"/>. Keys that do not exist in the dictionary are ignored.
        /// </summary>
        /// <typeparam name="TKey">The type of keys.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="keys">The keys whose values to get.</param>
        /// <returns>The values associated with the specified specified <paramref name="keys" />, if they exist in the dictionary.</returns>
        public static TValue[] TryGetValues<TKey, TValue>(this IDictionary<TKey, TValue> dict, TKey[] keys)
        {
            var keycount = keys.Length;
            var output = new List<TValue>(keycount);
            for (var i = 0; i < keycount; ++i)
            {
                if (dict.TryGetValue(keys[i], out var value))
                    output.Add(value);
            }
            return output.ToArray();
        }

        /// <summary>
        /// Tries to solve the specified <paramref name="key" />. Returns <paramref name="key" /> itself if it cannot be solved.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="key">The key to solve.</param>
        /// <remarks>This method continues to try to retrieve object if the specified <paramref name="key" /> refers to an object of type <typeparamref name="TKey" />. For example, if the dictionary contains three pairs "(key, obj1)", "(obj1, obj2)" and "(obj2, obj3)", then solving "key" will return "obj3"; if the dictionary contains two pairs "(key, obj1)", "(obj2, obj3)", then solving "key" will return "obj1".</remarks>
        /// <returns>The solved object, or the <paramref name="key" /> itself if it cannot be solved.</returns>
        public static object Solve<TKey>(this IDictionary<TKey, object> dict, TKey key)
        {
            if (dict == null) return key;
            object output = key;
            while (dict.TryGetValue(key, out var tmp))
            {
                output = tmp;
                if (tmp is TKey key1) key = key1;
                else break;
            }
            return output;
        }

        #endregion


        #region Add


        /// <summary>
        /// Adds an element with the provided key if the key does not exist in the current dictionary.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="key">The key of the element to add.</param>
        /// <param name="value">The element to add with the <paramref name="key"/>.</param>
        /// <returns><c>true</c> if the provided <paramref name="key"/> does not exist in the dictionary and the <paramref name="value"/> is added to the dictionary; otherwise, <c>false</c>.</returns>
        public static bool TryAdd<TKey, TValue>(this IDictionary<TKey, TValue> dict, TKey key, TValue value)
        {
            if (dict.ContainsKey(key)) return false;
            dict.Add(key, value);
            return true;
        }

        /// <summary>
        /// Adds an element with the provided key if the key does not exist, or overwrites an existing element associated with the specified key. The operation is the same as <see cref="Update{TKey,TValue}(System.Collections.Generic.IDictionary{TKey,TValue},TKey,TValue)"/>, but the return value is different.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="key">The key of the element to add or overwrite.</param>
        /// <param name="value">The element to add or overwrite with the <paramref name="key"/>.</param>
        /// <returns><c>true</c> if an old value with the specified <paramref name="key"/> already exists and is replaced by the provided <paramref name="value"/>; <c>false</c> if the <paramref name="key"/> does not exist and a new <paramref name="key"/>-<paramref name="value"/> pair is created.</returns>
        public static bool SetOrAdd<TKey, TValue>(this IDictionary<TKey, TValue> dict, TKey key, TValue value)
        {
            if (dict.TryGetValue(key, out var oldVal))
            {
                dict[key] = value;
                return true;
            }

            dict.Add(key, value);
            return false;
        }


        /// <summary>
        /// Adds an element with the provided key if the key does not exist, or overwrites an existing element associated with the specified key.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="key">The key of the element to add or overwrite.</param>
        /// <param name="value">The element to add or overwrite with the <paramref name="key"/>.</param>
        /// <returns><c>true</c> if an old value with the specified <paramref name="key"/> already exists and is replaced by the provided <paramref name="value"/>, or if the <paramref name="key"/> does not exist and a new <paramref name="key"/>-<paramref name="value"/> pair is created; <c>false</c> if the dictionary stays unchanged.</returns>
        public static bool Update<TKey, TValue>(this IDictionary<TKey, TValue> dict, TKey key, TValue value)
        {
            if (dict.TryGetValue(key, out var oldVal))
            {
                if (oldVal.Equals((value))) return false;
                dict[key] = value;
                return true;
            }

            dict.Add(key, value);
            return true;
        }


        public static bool UpdateWithCounting<TKey, TValue>(this IDictionary<TKey, (TValue, int)> dict, TKey key, TValue value)
        {
            if (dict.TryGetValue(key, out var oldVal))
            {
                if (oldVal.Item1.Equals((value))) return false;
                dict[key] = (value, oldVal.Item2 + 1);
                return true;
            }

            dict.Add(key, (value, 0));
            return true;
        }

        

        /// <summary>
        /// Adds an element with the provided key if the key does not exist, or overwrites an existing element associated with the specified key.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="key">The key of the element to add or overwrite.</param>
        /// <param name="newValue">The element to add or overwrite with the <paramref name="key"/>.</param>
        /// <param name="updateCondition">A method that defines a condition which must be satisfied before an existing value in the dictionary is replaced by the provided new value. This method takes the existing value as first argument, the <paramref name="newValue"/> as the second argument, and outputs a <see cref="bool"/> value indicating if the condition is satisfied.</param>
        /// <returns>A <see cref="UpdateResult.Added"/> if a new key-value pair is created; <see cref="UpdateResult.Updated"/> if the existing value of the same <paramref name="key"/> is updated by the <paramref name="newValue"/>; otherwise <see cref="UpdateResult.NoChange"/>.</returns>
        public static UpdateResult Update<TKey, TValue>(this IDictionary<TKey, TValue> dict, TKey key, TValue newValue, Func<TValue, TValue, bool> updateCondition)
        {
            if (dict.TryGetValue(key, out var oldValue))
            {
                if (updateCondition != null && !updateCondition(oldValue, newValue))
                    return UpdateResult.NoChange;
                dict[key] = newValue;
                return UpdateResult.Updated;
            }

            dict.Add(key, newValue);
            return UpdateResult.Added;
        }


        /// <summary>
        /// Adds the specified key-value pair collection to this dictionary.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="keyValueCollection">The key-value collection that contains <see cref="KeyValuePair{TKey, TValue}"/> to be added.</param>
        public static void Add<TKey, TValue>(this IDictionary<TKey, TValue> dict, IEnumerable<KeyValuePair<TKey, TValue>> keyValueCollection)
        {
            foreach (var pair in keyValueCollection)
                dict.Add(pair);
        }

        /// <summary>
        /// Adds the key-value pairs enumerated by the specified enumerator to this dictionary.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="enumerator">The enumerator that enumerates key-value pairs.</param>
        public static void Add<TKey, TValue>(this IDictionary<TKey, TValue> dict, IEnumerator<KeyValuePair<TKey, TValue>> enumerator)
        {
            if (enumerator != null)
            {
                while (enumerator.MoveNext())
                {
                    var curr = enumerator.Current;
                    dict.Add(curr.Key, curr.Value);
                }
            }
        }

        /// <summary>
        /// Adds the specified collection of values to this dictionary. The key of each value is generated by <paramref name="keyGenerator"/>.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="keyGenerator">The key generator that produces key for each value in <paramref name="valueCollection"/>.</param>
        /// <param name="valueCollection">The collection of values to be added to this dictionary.</param>
        /// <exception cref="System.ArgumentNullException">Occurs if <paramref name="keyGenerator"/> is <c>null</c>.</exception>
        public static void Add<TKey, TValue>(this IDictionary<TKey, TValue> dict, Func<TValue, TKey> keyGenerator, IEnumerable<TValue> valueCollection)
        {
            if (keyGenerator == null) throw new ArgumentNullException(nameof(keyGenerator));

            if (valueCollection != null)
            {
                foreach (TValue value in valueCollection)
                    dict.Add(keyGenerator(value), value);
            }
        }

        /// <summary>
        /// Adds the specified <paramref name="keys"/> and <paramref name="values"/> to this dictionary. If the sizes of these two arrays are not equal, the the smaller size will be used.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="keys">The keys to be added. The element of index <c>i</c> will be used as the key of <c>values[i]</c>.</param>
        /// <param name="values">The values to be added. The element of index <c>i</c> will be keyed by <c>keys[i]</c>.</param>
        public static void Add<TKey, TValue>(this IDictionary<TKey, TValue> dict, TKey[] keys, TValue[] values)
        {
            if (keys == null || values == null) return;
            var count = Math.Min(keys.Length, values.Length);
            for (int i = 0; i < count; ++i)
                dict.Add(keys[i], values[i]);
        }

        /// <summary>
        /// Adds the specified key-value pair collection to this dictionary. Duplicate keys will be ignored.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="keyValueCollection">The key-value collection that contains <see cref="Pair{TKey, TValue}"/> to be added.</param>
        public static void AddWithDuplicationCheck<TKey, TValue>(this IDictionary<TKey, TValue> dict, IEnumerable<Pair<TKey, TValue>> keyValueCollection)
        {
            if (keyValueCollection != null)
            {
                foreach (var pair in keyValueCollection)
                {
                    var key = pair.Item1;
                    var value = pair.Item2;
                    if (!dict.ContainsKey(key))
                        dict.Add(key, value);
                }
            }
        }

        /// <summary>
        /// Adds the specified key-value pair collection to this dictionary. Duplicate keys will be ignored.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="keyValueCollection">The key-value collection that contains <see cref="KeyValuePair{TKey, TValue}"/> to be added.</param>
        public static void AddWithDuplicationCheck<TKey, TValue>(this IDictionary<TKey, TValue> dict, IEnumerable<KeyValuePair<TKey, TValue>> keyValueCollection)
        {
            if (keyValueCollection != null)
            {
                foreach (var pair in keyValueCollection)
                {
                    var key = pair.Key;
                    var value = pair.Value;
                    if (!dict.ContainsKey(key))
                        dict.Add(key, value);
                }
            }
        }

        /// <summary>
        /// Adds the key-value pairs enumerated by the specified enumerator to this dictionary. Duplicate keys will be ignored.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="enumerator">The enumerator that enumerates key-value pairs.</param>
        public static void AddWithDuplicationCheck<TKey, TValue>(this IDictionary<TKey, TValue> dict, IEnumerator<KeyValuePair<TKey, TValue>> enumerator)
        {
            if (enumerator != null)
            {
                while (enumerator.MoveNext())
                {
                    var curr = enumerator.Current;
                    var key = curr.Key;
                    var value = curr.Value;
                    if (!dict.ContainsKey(key))
                        dict.Add(key, value);
                }
            }
        }


        #endregion

        /// <summary>
        /// Outputs one array <paramref name="keys"/> that contains all keys in the dictionary, and the other array <paramref name="values"/> that contains all values in the dictionary.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="keys">Outputs an array keys of this dictionary.</param>
        /// <param name="values">Outputs an array of values of this dictionary.</param>
        public static void ToKeysAndValues<TKey, TValue>(this IDictionary<TKey, TValue> dict, out TKey[] keys, out TValue[] values)
        {
            var count = dict.Count;
            keys = new TKey[count];
            values = new TValue[count];
            var i = 0;
            foreach (var pair in dict)
            {
                keys[i] = pair.Key;
                values[i] = pair.Value;
                ++i;
            }
        }

        /// <summary>
        /// Use the current dictionary to index the specified sequence of type <typeparamref name="TKey" /> and returns the resulting indices.
        /// </summary>
        /// <typeparam name="TKey">The key type of the dictionary.</typeparam>
        /// <param name="dict">A dictionary with <typeparamref name="TKey" /> as its key type and <see cref="int" /> as its value type.</param>
        /// <param name="sequence">The sequence of objects to index.</param>
        /// <param name="baseIndex">The base index. The default is zero.</param>
        /// <returns>A sequence of indices for objects in the input <paramref name="sequence" />.</returns>
        public static int[] Index<TKey>(this IDictionary<TKey, int> dict, IEnumerable<TKey> sequence, int baseIndex = 0)
        {
            var list = new List<int>();
            foreach (var key in sequence)
            {
                if (!dict.TryGetValue(key, out int index))
                {
                    index = dict.Count + baseIndex;
                    dict.Add(key, index);
                }

                list.Add(index);
            }

            return list.ToArray();
        }

        public static int[] IndexAndCount<TKey>(this IDictionary<TKey, (int, int)> dict, IEnumerable<TKey> sequence, int baseIndex = 0)
        {
            var list = new List<int>();
            foreach (var key in sequence)
            {
                int index;
                if (!dict.TryGetValue(key, out (int, int) tuple))
                {
                    index = dict.Count + baseIndex;
                    tuple.Item1 = index;
                    tuple.Item2 = 1;
                    dict.Add(key, tuple);
                }
                else
                {
                    index = tuple.Item1;
                    ++tuple.Item2;
                    dict[key] = tuple; //! (int,int) tuple is a struct, and it has to be written back
                }

                list.Add(index);
            }

            return list.ToArray();
        }

        /// <summary>
        /// Use the current dictionary to index the specified sequence of type <typeparamref name="TKey" /> and the resulting indices are appended to the specified <paramref name="outputList" />.
        /// </summary>
        /// <typeparam name="TKey">The key type of the dictionary.</typeparam>
        /// <param name="dict">A dictionary with <typeparamref name="TKey" /> as its key type and <see cref="int" /> as its value type.</param>
        /// <param name="sequence">The sequence of objects to index.</param>
        /// <param name="outputList">The list where resulting indices are appended to.</param>
        /// <param name="baseIndex">The base index. The default is zero.</param>
        public static void Index<TKey>(this IDictionary<TKey, int> dict, IEnumerable<TKey> sequence, IList<int> outputList, int baseIndex = 0)
        {
            foreach (var key in sequence)
            {
                if (!dict.TryGetValue(key, out int index))
                {
                    index = dict.Count + baseIndex;
                    dict.Add(key, index);
                }

                outputList.Add(index);
            }
        }

        public static void IndexAndCount<TKey>(this IDictionary<TKey, (int, int)> dict, IEnumerable<TKey> sequence, IList<int> outputList, int baseIndex = 0)
        {
            foreach (var key in sequence)
            {
                int index;
                if (!dict.TryGetValue(key, out (int, int) tuple))
                {
                    index = dict.Count + baseIndex;
                    tuple.Item1 = index;
                    tuple.Item2 = 1;
                    dict.Add(key, tuple);
                }
                else
                {
                    index = tuple.Item1;
                    ++tuple.Item2;
                    dict[key] = tuple; //! (int,int) tuple is a struct, and it has to be written back
                }

                outputList.Add(index);
            }
        }

        /// <summary>
        /// Use the current dictionary to index the specified <paramref name="key" />. If the <paramref name="key" /> does not exist in the current dictionary, the the number of keys in the current <see cref="IDictionary{TKey, TValue}.Keys" /> will be assigned as the integer index of the provided <paramref name="key" />, and the key-index pair will be saved in the dictionary; otherwise the dictionary is unmodified.
        /// </summary>
        /// <typeparam name="TKey">The type of the t <paramref name="key" />.</typeparam>
        /// <param name="dict">The dictionary.</param>
        /// <param name="key">The key.</param>
        /// <param name="baseIndex">The base index. The default is zero.</param>
        /// <returns>The integer index of <paramref name="key" />.</returns>
        public static int Index<TKey>(this IDictionary<TKey, int> dict, TKey key, int baseIndex = 0)
        {
            if (!dict.TryGetValue(key, out int index))
            {
                index = dict.Count + baseIndex;
                dict.Add(key, index);
            }
            return index;
        }

        public static int IndexAndCount<TKey>(this IDictionary<TKey, (int, int)> dict, TKey key, int baseIndex = 0)
        {
            int index;
            if (!dict.TryGetValue(key, out (int, int) tuple))
            {
                index = dict.Count + baseIndex;
                tuple.Item1 = index;
                tuple.Item2 = 1;
                dict.Add(key, tuple);
            }
            else
            {
                index = tuple.Item1;
                ++tuple.Item2;
                dict[key] = tuple; //! (int,int) tuple is a struct, and it has to be written back
            }

            return index;
        }

        public static int IndexAndCount<TKey>(this IDictionary<TKey, (int, double, double)> dict, TKey key, double statistic1, double statistic2, int baseIndex = 0)
        {
            int index;
            if (!dict.TryGetValue(key, out (int, double, double) tuple))
            {
                index = dict.Count + baseIndex;
                tuple.Item1 = index;
                tuple.Item2 = statistic1;
                tuple.Item3 = statistic2;
                dict.Add(key, tuple);
            }
            else
            {
                index = tuple.Item1;
                tuple.Item2 += statistic1;
                tuple.Item3 += statistic2;
                dict[key] = tuple;
            }

            return index;
        }

        public static int IndexAndCount<TKey>(this IDictionary<TKey, (int, int, double)> dict, TKey key, double statistic, int baseIndex = 0)
        {
            int index;
            if (!dict.TryGetValue(key, out (int, int, double) tuple))
            {
                index = dict.Count + baseIndex;
                tuple.Item1 = index;
                tuple.Item2 = 1;
                tuple.Item3 = statistic;
                dict.Add(key, tuple);
            }
            else
            {
                index = tuple.Item1;
                ++tuple.Item2;
                tuple.Item3 += statistic;
                dict[key] = tuple;
            }

            return index;
        }


        #region Stat

        /// <summary>
        /// Increaces the counting for the specified <paramref name="key" />. If the <paramref name="key" /> does not exist in the current dictionary, a new entry will be added.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <param name="dict">The current counting dictionary.</param>
        /// <param name="key">The key whose count is to be increased.</param>
        /// <param name="increament">The increament, default is <c>1</c>.</param>
        /// <returns>The current count for <paramref name="key"/> in this counting dictionary.</returns>
        public static void Stat<TKey>(this IDictionary<TKey, int> dict, TKey key, int increament = 1)
        {
            if (!dict.TryGetValue(key, out var stat))
                dict.Add(key, increament);
            else
                dict[key] = stat + increament;
        }

        /// <summary>
        /// Increaces the counting for the specified <paramref name="key" /> and returns the count after the increment. If the <paramref name="key" /> does not exist in the current dictionary, a new entry will be added.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <param name="dict">The current counting dictionary.</param>
        /// <param name="key">The key whose count is to be increased.</param>
        /// <param name="increament">The increament, default is <c>1</c>.</param>
        /// <returns>The current count for <paramref name="key"/> in this counting dictionary.</returns>
        public static int StatAndGet<TKey>(this IDictionary<TKey, int> dict, TKey key, int increament = 1)
        {
            if (!dict.TryGetValue(key, out var stat))
            {
                dict.Add(key, increament);
                return 1;
            }
            else
            {
                var newCount = stat + increament;
                dict[key] = newCount;
                return newCount;
            }
        }

        /// <summary>
        /// Increaces the counting for the specified <paramref name="key"/>. Adds the <paramref name="increament"/> arithmetically to the <see cref="Pair{T}"/> associated with specified <paramref name="key"/>. If the <paramref name="key"/> does not exist in the current dictionary, a new entry will be added.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <param name="dict">The current counting dictionary.</param>
        /// <param name="key">The key whose count is to be increased.</param>
        /// <param name="increament">The increament to be added to the <see cref="Pair{T}"/> associated with specified <paramref name="key"/>.</param>
        public static void Stat<TKey>(this IDictionary<TKey, Pair<int>> dict, TKey key, (int, int) increament)
        {
            if (!dict.TryGetValue(key, out var stat))
                dict.Add(key, increament);
            else
                dict[key] = stat + increament;
        }

        /// <summary>
        /// Increaces the counting for the specified <paramref name="key"/>. Adds the <paramref name="increament"/> arithmetically to the <see cref="Pair{T}"/> associated with specified <paramref name="key"/>. If the <paramref name="key"/> does not exist in the current dictionary, a new entry will be added.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <param name="dict">The current counting dictionary.</param>
        /// <param name="key">The key whose count is to be increased.</param>
        /// <param name="increament">The increament to be added to the <see cref="double"/> tuple associated with specified <paramref name="key"/>.</param>
        public static void Stat<TKey>(this IDictionary<TKey, (double, double)> dict, TKey key, (double, double) increament)
        {
            if (!dict.TryGetValue(key, out var stat))
                dict.Add(key, increament);
            else
                dict[key] = (stat.Item1 + increament.Item1, stat.Item2 + increament.Item2);
        }

        /// <summary>
        /// Increaces the first counting for the specified <paramref name="key"/>. Adds the <paramref name="increament"/> to the <c>Item1</c> property of the <see cref="Pair{T}"/> associated with specified <paramref name="key"/>. If the <paramref name="key"/> does not exist in the current dictionary, a new entry will be added.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <param name="dict">The current counting dictionary.</param>
        /// <param name="key">The key whose first count is to be increased.</param>
        /// <param name="increament">The increament to the count.</param>
        public static void StatItem1<TKey>(this IDictionary<TKey, Pair<int>> dict, TKey key, int increament = 1)
        {
            if (!dict.TryGetValue(key, out var stat))
                dict.Add(key, (increament, 0));
            else
                stat.Item1 += increament;
        }

        /// <summary>
        /// Increaces the second counting for the specified <paramref name="key"/>. Adds the <paramref name="increament"/> to the <c>Item2</c> property of the <see cref="Pair{T}"/> associated with specified <paramref name="key"/>. If the <paramref name="key"/> does not exist in the current dictionary, a new entry will be added.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <param name="dict">The current counting dictionary.</param>
        /// <param name="key">The key whose second count is to be increased.</param>
        /// <param name="increament">The increament to the count.</param>
        public static void StatItem2<TKey>(this IDictionary<TKey, Pair<int>> dict, TKey key, int increament)
        {
            if (!dict.TryGetValue(key, out var stat))
                dict.Add(key, (0, increament));
            else
                stat.Item2 += increament;
        }

        /// <summary>
        /// Increaces the counting for the specified <paramref name="key"/>. If the <paramref name="key"/> does not exist in the current dictionary, a new entry will be added.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <param name="dict">The current counting dictionary.</param>
        /// <param name="key">The key whose count is to be increased.</param>
        /// <param name="increament">The increament, default is <c>1</c>.</param>
        public static void Stat<TKey>(this IDictionary<TKey, double> dict, TKey key, double increament = 1.0)
        {
            if (!dict.TryGetValue(key, out var stat))
                dict.Add(key, increament);
            else
                dict[key] = stat + increament;
        }

        /// <summary>
        /// Increaces the counting for the specified <paramref name="key" />. Adds the <paramref name="increament"/> arithmetically to the <see cref="Pair{TKey,TValue}"/> associated with specified <paramref name="key"/>. If the <paramref name="key" /> does not exist in the current dictionary, a new entry will be added.
        /// </summary>
        /// <typeparam name="TKey">The type of the key.</typeparam>
        /// <typeparam name="TValue">The type of the increament.</typeparam>
        /// <param name="dict">The current counting dictionary.</param>
        /// <param name="key">The key whose count is to be increased.</param>
        /// <param name="increament">The increament.</param>
        public static void Stat<TKey, TValue>(this IDictionary<TKey, TValue> dict, TKey key, TValue increament)
        {
            if (!dict.TryGetValue(key, out var stat))
                dict.Add(key, increament);
            else
            {
                var type = typeof(TValue);
                var fields = type.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.SetField | BindingFlags.GetField);
                foreach (var field in fields)
                    field.SetValue(stat, (dynamic)field.GetValue(stat) + (dynamic)(field.GetValue(increament)));
                var properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.SetProperty | BindingFlags.GetProperty);
                foreach (var property in properties)
                    property.SetValue(stat, (object)((dynamic)property.GetValue(stat) + (dynamic)property.GetValue(increament)));
            }

        }

        /// <summary>
        /// Merges the countings of a sequence of dictionaries.
        /// </summary>
        /// <typeparam name="TKey">The type of the key in the counting dictionaries.</typeparam>
        /// <typeparam name="TValue">The type of count values in the counting dictionaries.</typeparam>
        /// <param name="dicts">The sequence of dictionaries to merge.</param>
        /// <returns>A new dictionary that merges the countings of the provided sequence of dictionaries.</returns>
        public static Dictionary<TKey, TValue> MergeStat<TKey, TValue>(this IEnumerable<IDictionary<TKey, TValue>> dicts)
        {
            var output = new Dictionary<TKey, TValue>();
            foreach (var dict in dicts)
            {
                foreach (var pair in dict)
                    output.Stat(pair.Key, pair.Value);
            }

            return output;
        }

        /// <summary>
        /// Merges the countings of a sequence of dictionaries.
        /// </summary>
        /// <typeparam name="TKey">The type of the key in the counting dictionaries.</typeparam>
        /// <typeparam name="TValue">The type of count values in the counting dictionaries.</typeparam>
        /// <param name="dicts">The sequence of dictionaries to merge.</param>
        /// <returns>A new dictionary that merges the countings of the provided sequence of dictionaries.</returns>
        public static Dictionary<TKey, TValue> MergeStat<TKey, TValue>(this IEnumerable<IDictionary> dicts)
        {
            var output = new Dictionary<TKey, TValue>();
            foreach (var dict in dicts)
            {
                foreach (DictionaryEntry pair in dict)
                    output.Stat((TKey)pair.Key, (TValue)pair.Value);
            }

            return output;
        }

        #endregion


    }
}
